%{

#include <iostream>
#include <cstdlib>
#include <string>
#include "sourcetree/ast.hpp"
#include "sourcetree/statement.hpp"

#include "llvm/IR/Value.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/Verifier.h"

extern FILE* yyin;

void yyerror(std::string msg) {
    std::cerr << msg << std::endl;
    exit(EXIT_FAILURE);
}

extern int yylex();

%}

%union {
    std::string* string_value;
    double double_value;
    ExprAST* expr_t;
    llvm::Function* func_t;
    std::vector<std::string>* str_vec;
    std::vector<ExprAST*>* expr_vec;
    Type type_t;
    Param* param_t;
    std::vector<Param*>* param_vec;
    Statement* statement_t;
    std::vector<Statement*>* statement_vec;
    FunctionAST* func_ast_t;
    ExternalFunctionStatement* extern_func_t;
    FunctionPrototypeAST* func_proto_ast_t;
    ExpressionStatement* expr_stat_t;
    CallExprAST* call_expr_ast_t;
    VarDeclarationStatement* var_decl_stat_t;
}

%left '+' '-'
%left '*' '/'

%token val_token var_token fun_token external_token return_token
%token int_type_token double_type_token string_type_token
%token <string_value> id_token
%token <double_value> num_token
%token <string_value> str_token

%type <expr_t> E
%type <param_t> Param
%type <type_t> Type
%type <param_vec> ParamArray
%type <expr_vec> ArgArray
%type <func_ast_t> FunctionDefStatement
%type <extern_func_t> ExternalFunctionStatement
%type <func_proto_ast_t> FunctionSignature
%type <expr_stat_t> ExpressionStatement
%type <statement_t> Statement DeclareAndAssignStatement AssignStatement
%type <statement_vec> StatementList Block
%type <var_decl_stat_t> VarDeclarationStatement

%%
Program: StatementList {
    for (Statement* statement : *$1) {
        statement->codegen();
    }
    delete $1;
}

StatementList: StatementList StatementSeparator Statement {
                 $$ = $1;
                 $$->push_back($3);
               }
               | Statement {
                  $$ = new std::vector<Statement*>();
                  $$->push_back($1);
               }
               ;

StatementSeparator: ';' | '\n' ;

Block: '{' StatementList '}' {
    $$ = $2;
}

Statement:
    VarDeclarationStatement {
      $$ = $1;
    }
    | AssignStatement {
      $$ = $1;
    }
    | DeclareAndAssignStatement {
      $$ = $1;
    }
    | FunctionDefStatement {
       $$ = $1;
    }
    | ExternalFunctionStatement {
       $$ = $1;
    }
    | ExpressionStatement {
       $$ = $1;
    } | return_token E {
       $$ = new ReturnStatement($2);
    }
    | {
        $$ = new EmptyStatement();
    }
    ;

DeclareAndAssignStatement: VarDeclarationStatement '=' E {
    std::string id = $1->getId();
    auto assign_statement = new AssignStatement(id, $3);
    $$ = new DeclareAndAssignStatement($1, assign_statement);
};

VarDeclarationStatement: var_token id_token ':' Type {
    $$ = new VarDeclarationStatement(*$2, $4, true);
    delete $2;
}

AssignStatement: id_token '=' E {
    $$ = new AssignStatement(*$1, $3);
    delete $1;
}

FunctionDefStatement: FunctionSignature '=' E {
    ReturnStatement* returnAST = new ReturnStatement($3);
    auto statements = new std::vector<Statement*>();
    statements->push_back(returnAST);
    $$ = new FunctionAST($1, statements);
}
| FunctionSignature Block {
    $$ = new FunctionAST($1, $2);
}

ExpressionStatement: E {
    $$ = new ExpressionStatement($1);
}

ExternalFunctionStatement: external_token FunctionSignature {
    $$ = new ExternalFunctionStatement($2);
}

FunctionSignature: fun_token id_token '(' ParamArray ')' ':' Type {
    $$ = new FunctionPrototypeAST(*$2, *$4, $7);
    delete $2;
    delete $4;
}

E:
  E '+' E {
    $$ = new AddExprAST($1, $3);
  }
  | E '-' E {
    $$ = new SubExprAST($1, $3);
  }
  | E '*' E {
    $$ = new MulExprAST($1, $3);
  }
  | E '/' E {
    $$ = new DivExprAST($1, $3);
  }
  | '(' E ')' {
    $$ = $2;
  }
  | id_token {
    $$ = new VarExprAST(*$1);
    delete $1;
  }
  | num_token {
    $$ = new ConstExprAST($1);
  }
  | str_token {
    $$ = new ConstStringExprAST(*$1);
    delete $1;
  }
  | id_token '(' ArgArray ')' {
    $$ = new CallExprAST(*$1, *$3);
    delete $1;
    delete $3;
  };

ArgArray: 
    ArgArray ',' E {
        $$ = $1;
        $$->push_back($3);
    }
  | E {
    $$ = new std::vector<ExprAST*>();
    $$->push_back($1);
  }
  | {
    $$ = new std::vector<ExprAST*>();
  }
  ;

ParamArray:
    ParamArray ',' Param {
        $$ = $1;
        $$->push_back($3);
    }
    | Param {
        $$ = new std::vector<Param*>();
        $$->push_back($1);
    }
    | {
        $$ = new std::vector<Param*>();
    }

Param: id_token ':' Type {
    $$ = new Param(*$1, $3);
    delete $1;
}

Type: int_type_token {
        $$ = INT;
    }
    | double_type_token {
        $$ = DOUBLE;
    } | string_type_token {
        $$ = STRING;
    };

%%

llvm::LLVMContext context;
llvm::IRBuilder<> builder(context);
llvm::Module* module;
std::map<std::string, llvm::AllocaInst*> named_values;

int main() {
    yyin = fopen("../test.kt", "r");
    module = new llvm::Module("My module", context);
    yyparse();
    module->print(llvm::outs(), nullptr);
    delete module;
    return 0;
}

