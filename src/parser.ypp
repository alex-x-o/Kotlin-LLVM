%{

#include <iostream>
#include <cstdlib>
#include <string>
#include "sourcetree/ast.hpp"
#include "sourcetree/statement.hpp"

#include "llvm/IR/Value.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/Verifier.h"

extern FILE* yyin;

void yyerror(std::string msg) {
    std::cerr << msg << std::endl;
    exit(EXIT_FAILURE);
}

extern int yylex();

%}

%union {
    std::string* string_value;
    double double_value;
    ExprAST* expr_t;
    llvm::Function* func_t;
    std::vector<std::string>* str_vec;
    std::vector<ExprAST*>* expr_vec;
    Type type_t;
    Param* param_t;
    std::vector<Param*>* param_vec;
    Statement* statement_t;
    std::vector<Statement*>* statement_vec;
    FunctionAST* func_ast_t;
    ExternalFunctionStatement* extern_func_t;
    FunctionPrototypeAST* func_proto_ast_t;
    ExpressionStatement* expr_stat_t;
    CallExprAST* call_expr_ast_t;
}

%left '+' '-'
%left '*' '/'

%token val_token var_token fun_token external_token return_token
%token int_type_token double_type_token string_type_token
%token <string_value> id_token
%token <double_value> num_token
%token <string_value> str_token

%type <expr_t> E
%type <param_t> Param
%type <type_t> Type
%type <param_vec> ParamArray
%type <expr_vec> ArgArray
%type <func_ast_t> FunctionDefStatement
%type <extern_func_t> ExternalFunctionStatement
%type <func_proto_ast_t> FunctionSignature
%type <expr_stat_t> ExpressionStatement
%type <statement_t> Statement
%type <statement_vec> StatementList

%%
Program: StatementList {
    for (Statement* statement : *$1) {
        statement->codegen();
    }
    delete $1;
}

StatementList: StatementList StatementSeparator Statement {
                 $$ = $1;
                 $$->push_back($3);
               }
               | Statement {
                  $$ = new std::vector<Statement*>();
                  $$->push_back($1);
               }
               ;

StatementSeparator: ';' | '\n' ;

Block: '{' OptNewline StatementList OptNewline '}';

OptNewline: '\n' | ;

Statement:
    AssignStatement {
      //TODO
      $$ = new EmptyStatement();
    }
    | FunctionDefStatement {
       $$ = $1;
    }
    | ExternalFunctionStatement {
       $$ = $1;
    }
    | ExpressionStatement {
        $$ = $1;
    }
    | {
        $$ = new EmptyStatement();
    }
    ;

AssignStatement:
    val_token id_token '=' E;

FunctionDefStatement: FunctionSignature '=' E {
    ReturnAST* returnAST = new ReturnAST($3);
    $$ = new FunctionAST($1, returnAST);
};

ExpressionStatement: E {
    $$ = new ExpressionStatement($1);
}

ExternalFunctionStatement: external_token FunctionSignature {
    $$ = new ExternalFunctionStatement($2);
}

FunctionSignature: fun_token id_token '(' ParamArray ')' ':' Type {
    $$ = new FunctionPrototypeAST(*$2, *$4, $7);
    delete $2;
    delete $4;
}

E:
  E '+' E {
    $$ = new AddExprAST($1, $3);
  }
  | E '-' E {
    $$ = new SubExprAST($1, $3);
  }
  | E '*' E {
    $$ = new MulExprAST($1, $3);
  }
  | E '/' E {
    $$ = new DivExprAST($1, $3);
  }
  | '(' E ')' {
    $$ = $2;
  }
  | id_token {
    $$ = new VarExprAST(*$1);
    delete $1;
  }
  | num_token {
    $$ = new ConstExprAST($1);
  }
  | str_token {
    $$ = new ConstStringExprAST(*$1);
    delete $1;
  }
  | return_token E {
    $$ = new ReturnAST($2);
  }
  | id_token '(' ArgArray ')' {
    $$ = new CallExprAST(*$1, *$3);
    delete $1;
    delete $3;
  };

ArgArray: 
    ArgArray ',' E {
        $$ = $1;
        $$->push_back($3);
    }
  | E {
    $$ = new std::vector<ExprAST*>();
    $$->push_back($1);
  }
  | {
    $$ = new std::vector<ExprAST*>();
  }
  ;

ParamArray:
    ParamArray ',' Param {
        $$ = $1;
        $$->push_back($3);
    }
    | Param {
        $$ = new std::vector<Param*>();
        $$->push_back($1);
    }
    | {
        $$ = new std::vector<Param*>();
    }

Param: id_token ':' Type {
    $$ = new Param(*$1, $3);
    delete $1;
}

Type: int_type_token {
        $$ = INT;
    }
    | double_type_token {
        $$ = DOUBLE;
    } | string_type_token {
        $$ = STRING;
    };

%%

llvm::LLVMContext context;
llvm::IRBuilder<> builder(context);
llvm::Module* module;
std::map<std::string, llvm::Value*> named_values;

int main() {
    yyin = fopen("../test.kt", "r");
    module = new llvm::Module("My module", context);
    yyparse();
    module->print(llvm::outs(), nullptr);
    delete module;
    return 0;
}

